Полиморфизм разделяется на 2 вида:
1. Этапа компиляции (ранее связывание, статический полиморфизм)
2. Этапа выполнения (позднее связывание, динамический полиморфизм)

К полиморфизму этапа компиляции относятся:
- перегрузка функций, операторов
К полиморфизму этапа выполнения относятся:
- использование иерархии классов и виртуальных функций и переопределение методов

Указатель на базовый класс может ссылаться на **любой** объект дочернего класса.

## Основа динамического полиморфизма
Обычно указатель одного типа не может указывать на экземпляры другого типа, однако указатели на базовые и производные классы являются исключениями из этого правила.

Используя указатель дочернего типа, нельзя получить доступ к объектам базового типа, если не использовать преобразование типов.

Указатель инкрементируется и декрементируется относительно своего базового типа. 
Т.е при "++" "--" указатель базового типа будет указывать на объект следующего базового типа.

	Виртуальная функция объявляется ключевым словом virtual и переопределяется в одном или нескольких дочерних классов. Если дочерний класс не переопределил метод, то для объекта дочернего класса вызывается метод для базового типа

По типу адресуемого объекта, а не по типу самого указателя определяется какая версия виртуальной функции будет вызвана

Прототипы виртуальных функций, которые её переопределили, должны полностью совпадать

Виртуальная функция должна быть элементом класса, а не его другом. Виртуальные функции передаются по наследству. Если метод объявлен виртуальным в базовом классе, то он остаётся виртуальным, независимо от уровня иерархии

Деструкторы могут быть виртуальными, конструкторы - нет.

Чисто виртуальные функции - функции, которые не имеют определения в базовом классе. Необходимо гарантировать что производный класс всегда переопределит все необходимые в базовом классе методы.
Чисто виртуальная функция никогда в базовом классе не имеет никакого переопределения. Для того, чтобы **отложить** реализацию функции нужно в прототипе прописать равно. 

Класс, который имеет хотя бы 1 чисто виртуальную функцию является недоделанным до конца, абстрактным
# Шаблоны. Шаблонные классы, параметризация
	Шаблон позволяет достичь многократно используемого кода. Используя шаблоны можно создавать обощенные функции и обощенные типы в которых обрабатываемый тип задается как параметр.
Тип не важен, если алгоритм обработки данных одинаков для любого типа.
Обобщенная функция перегружает саму себя.

Определение любой обобщенной функции  начинается со слова *template* после которого указываются угловые скобки, содержащие перечень заглушек типов (1 или более) и затем описывается тело функции.
Шаблонный код читать намного сложнее потому что в нем много доп угловых скобок.
Между template инструкции и телом функции не должно быть никаких других операторов, но для удобства часто template инструкции и тело функций находятся на разных точках.

В любой обобщённой функции можно использовать один и более типов, используя список, разделенный запятой. Любой такой функции можно создать явную реализацию. Т.е написать функцию без шаблона.
Обычно явную специализацию предваряют *template <>*
Используется для быстрого рефакторинга под новые типы

любую шаблонную функцию можно перегрузить. Любой шаблонной функции кроме шаблонных параметров.
Могут быть шаблонные типы, которые обладают свойством константности т.е могут быть использованы как размер статического массива