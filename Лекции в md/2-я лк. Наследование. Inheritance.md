#ООПиП 
## Наследование
	Наследование - один из принципов ООП, который позволяет создавать новые классы (наследники (подклассы, производные)) из уже существующих (базовых (родительских)). 
	
Это приводит к повторному использованию кода (code reuse) производный класс получает **ВСЕ** возможности базового класса, но может быть усовершенствован, за счет добавления новых возможностей. При этом базовый класс остается неизменным. 

Стрелка генерализации на диаграммах UML **ВСЕГДА** указывает на базовый класс. 

Атрибутом по умолчанию при наследовании между классами является *private*.

Наследование должно отвечать на вопрос "Является Х". 
	"Ученик НЕ является университетом" - наследование недопустимо

модификатор доступа *Protected* используется если необходимо, чтобы поле или метод класс были доступны внутри текущего класса и в любом другом дочернем классе.

*private* компоненты не наследуются. Т.е элементам с атрибутом private базового класса дочерние классы доступа не имеют. 
Конструкторы и деструкторы **НЕ** наследуются, но для создания объектов дочернего класса всегда используется конструкторы всех базовых классов.

Для разрушения объекта дочернего класса деструкторы вызываются начиная с дочернего класса и вверх по иерархии до деструктора самого верхнего класса.
### Переопределение методов (Overriding)
В производном классе методы могут иметь такое же имя, как и в базовом. Сигнатура метода при этом должна совпадать. При этом реализации в базовом и дочернем классе будут различны. Это называется *переопределение метода*

Сигнатура метода не включает в себя возвращаемый тип.
Для того, чтобы понять, какой метод базового или дочернего класса необходимо вызвать, компилятор анализирует тип объекта, для которого этот метод вызвался.

При необходимости к реализации метода базового класса, необходимо указать его имя и оставить оператор расширения области видимости.

Иерархия классов не дублирует организационную структуру предприятия. Часто в иерархии классов самый верхний класс является настолько общим, что его необходимо сделать абстрактным. Важно учитывать комбинации атрибутов доступа.

Схема доступов:

| public<br>protected<br>private | ->public->    | public<br>protected    |
| ------------------------------ | ------------- | ---------------------- |
| public<br>protected<br>private | ->protected-> | protected<br>protected |
| public<br>protected<br>private | ->private->   | private<br>private     |
Обычно поля открытые или защищенные. Методы - открытые.

### Множественное наследование
Класс может быть производным от двух и более классов.
*Это называется множественным наследованием*

При множественном наследовании, конструкторы вызываются в порядке, в котором указываются базовые классы при наследовании.

Если в двух базовых классах, присутствуют методы с одинаковыми сигнатурами. А в дочернем такого нет, то возникает неоднозначность (какой метод из какого класса надо вызвать)
Эту неоднозначность можно устранить указав:

	имя базового класса оператора :: и имя нужного метода
Во многих языках программирования множественное наследование классов запрещено. Но при этом разрешено множественное наследование интерфейсов.
## Связи
Наследование не является единственной связью между классами.
Например есть связь *Агрегация,* *Композиция*, *Ассоциация*, *Зависимость* и другие

Пример:
Машина и транспортное средство связаны связью **Наследование**, но библиотека и книга связаны связью "*Содержит, включает*" (Т.е **Агрегация**).
### Основные связи, когда класс находится в классе
- Агрегация
- Композиция

Есть понятие *контейнера* и *части*
- Контейнер - факультет
- Часть - студент, сотрудник факультета

При агрегации разрушения контейнера не приводит к разрушению части.
При композиции разрушение контейнера приводит к разрушению части.
